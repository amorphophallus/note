# 51 单片机

[TOC]

## C51 编程

1. C51
    - 在 C 基础上增加了便于访问单片机内存的 **sbit**(special bit) 和 **sfr**(special function register，), **code** 变量类型。
        - 声明1：用地址声明 `sfr P0 = 0x80; sbit P0_0 = 0x80;`
        - 声明2：用 sfr 声明 sbit `sbit P3_4 = P3^4;`
        - 调用：`if (P3_1 == 0) P2_0 = 0;` 可以直接对寄存器进行读和写。
        - `code` 修饰的变量，其内存将申请 ROM(FLASH) 上。FLASH 空间更大，但是不能在软件中更改。例如 `unsigned char code Animation[32];`。
    - 只能在函数或者循环的开头定义局部变量
    - 引用头文件 `REGX52.H`，可以直接调用定义好的端口，例如 `P2, P2_0`
    - 因为存储空间有限，经常用 `char`(-128 ~ 127) 和 `unsigned char`(0 ~ 255)，需要注意符号和数据范围的问题
2. Keil5
    - 在 Keil5 中定义和使用模板： `|` 表示使用模板之后光标跳转的位置
3. 常用模块
    1. 延时模块：用空语句占用时间，空语句数量通过主频计算，在 stc-isp 软件内可生成延时函数
    2. 按键防抖模块：按键状态发生变化时延时 20 ms
4. 模块化编程：
    - 在函数实现的 `.c` 文件中不需要包含函数的声明，只需要在想调用函数的地方引用 `.h` 就行了。![Alt text](./img/51_delay.png)
    - 使用到的自定义函数的 `.c` 文件必须添加到工程参与编译，使用到的 `.h` 文件必须要放在编译器可寻找到的地方（工程文件夹根目录、安装目录、自定义）


## 开发板原理图

1. 数码管
    1. 共阴极
    2. 通过 38 译码器选择数码管，74HC138 译码器 A, B, C 引脚代表二进制数的低、中、高位。
    3. P00 到 P07 端口分别对应 LED a, b, ..., g, dp
    4. 消影：段选、位选是交替进行的，当段选已经选中下一个数码管时，位选仍保持着上一个数码管的数据，会被显示在下一个数码管上，产生重叠。需要在每次显示之后重置位选。
    5. 驱动方式
        - 单片机直接扫描：只用单片机占用 11 个接口，用 74H595 只需要 3 个接口。
        - 专用驱动芯片：TM1640，不需要占用大量 CPU 时间进行扫描
2. 74HC245 模块功能：
    1. DIR 引脚控制数字信号传递的方向
    2. 增强驱动能力：输入的高低电平信号增强为 Vcc 和 Gnd
3. LCD1602
4. 矩阵键盘
    - 扫描：IO 口从 16 个减少到 8 个（n^2 减少到 2n）
    - 思路1：按行扫描或者按列扫描
    - 思路2：先扫描整个矩阵判断是否有按键按下，当有按键按下后再按行或列扫描确定按下的位置。这种方法优点是检测更加灵敏，缺点是引脚冲突导致蜂鸣器乱叫。
    - 问题1：若按行扫描，P15 口引脚冲突，扫描时蜂鸣器同时工作。按列扫描不会出现问题。
    - 问题2：作为输入口时，IO 口的输出需要设为高电平，否则输入的高电平无法被检测到。
    - 问题3：在一个按键松开之前不能检测到另一个按键按下。扫描的弊端。
5. 单片机 I/O 口
    - 准双向口：既可以作为输入口，又可以作为输出口
    - 弱上拉强下拉：可以简单理解成，输出高电平时，在 IO 口和 Vcc 之间连一个电阻，允许外接设备将电平拉低；输出低电平时，IO 口直接接地。
    - 其他 I/O 模式：高阻输入 - 内部高阻态，输入高低电平均不会短路。推挽输出 - 直连 Vcc 增强驱动能力。开漏输出 - MOS 管输出，驱动能力较弱。
6. 定时器 / 计数器 （关于定时器和中断的具体功能和实现详见手册）  ![Alt text](./img/51_timer.png)
    - 是单片机内部资源。可实现软件计时，或者使程序每隔一固定时间完成一项操作，替代长时间 Delay
    - STC89C52 的 T0 有四种工作模式
        - 模式0：13位定时器/计数器
        - 模式1：16位定时器/计数器（常用）。不会自动重装，需要在中断函数中重新初始化
        - 模式2：8位**自动重装**模式。**TL 累加，TH 不变，溢出时将 TH 重装入 TL。**
        - 模式3：两个8位计数器
        - 注意1：T1 没有第 3 种
        - 注意2：**TF 由硬件置 1，直到 CPU 响应中断（不允许中断也算响应了）由硬件置 0**，无需软件设置
    - 定时器相关寄存器 ![Alt text](./img/51_register.png)
        - $C/\overline{T}$：
            - 作用：选择使用内部时钟作为输入或者使用外部脉冲输入作为输入
            - 硬件：是寄存器 TMOD 的一位，不可位寻址，通过电路连线直接控制定时器中的开关
            - 若使用内部时钟，每 1us 计数器加一，可以通过设置计数器初始值来计一个特定时间。
        - TMOD：高 4 位控制 T1，低 4 位控制 T0
        - GATE 和 TR0：计数器的开关，$TR0 \wedge(\overline{GATE}\vee \overline{INT0})$ 为真时计数器才工作
        - TL, TH, TF: timer low, timer high, timer flow(1 bit)
    - 中断：
        - 中断源：8个（外部中断0、定时器0中断、外部中断1、定时器1中断、串口中断、定时器2中断、外部中断2、外部中断3），不同型号的单片机不同 ![Alt text](./img/51_interrupt_structure.png)
        - 中断优先级
        - 中断号 ![Alt text](./img/51_interupt.png)
        - 注意：中断函数尽量简单，否则会导致主函数程序执行效率低下。
        - 中断相关寄存器（查手册）
7. 串口通信
    - 51 单片机中实现串口通信的模块：**UART（Universal Asynchronous Receiver Transmitter，通用异步收发器）**
    - 最简单的双向通信串口模型如下图，TXD(transmit exchange data), RXD(receive exchange data), Vcc 供电，GND 提供标准 0 电平，因为高低电平都是以 GND 为标准的。如果两边电平标准不同则还需要加电平转换芯片 ![Alt text](./img/51_TXD.png)
    - 电平标准：
        - TTL电平：+5V表示1，0V表示0
        - RS232电平：-3 ~ -15V表示1，+3 ~ +15V表示0（可容忍的电压变化更大，抗干扰能力更强）
        - RS485电平：两线压差+2 ~ +6V表示1，-2 ~ -6V表示0（差分信号，一个信号需要两根线，但是能够进行更长距离的传输，稳定性更好，例如 USB，CAN）
    - 术语：
        - 全双工：通信双方可以在同一时刻互相传输数据
        - 半双工：通信双方可以互相传输数据，但必须分时复用一根数据线
        - 单工：通信只能有一方发送到另一方，不能反向传输
        - 异步：通信双方各自约定通信速率
        - 同步：通信双方靠一根时钟线来约定通信速率
        - 总线：连接各个设备的数据传输线路（类似于一条马路，把路边各住户连接起来，使住户可以相互交流）
        - 波特率：单位时间内载波调制状态变化的次数，即串口通信每秒钟传输符号的个数。
            - 注意1：注意与比特率区分。
            - 注意2：一个符号可以负载多个比特信息，例如在 51 单片机中可能是 8 bit 或者 9 bit 信息为一个符号，取决于串口工作模式。所以需要注意波特率的单位是 Bd 还是 bps。
            - 注意3：波特率可能无法精确设定为某些值，从而产生一定的误差。例如在 12MHz 时钟频率的单片机中无法设置波特率为 4800，因为无法整除。
            - 计算：例如单片机时钟频率为 11.0592MHz，工作在 12T 模式，Timer1 工作在 8 位定时器模式；需要波特率为 Bd = 4800bps，串口波特率不翻倍（SMOD=0）。根据时钟频率可知，单片机每秒有 SysClk = 11059200 个时钟周期；因为 12 个时钟周期为一个指令周期（12T），所以每秒有 SysClk / 12 个指令周期；因为 T1 每秒溢出次数为 SysClk / 12 / (65536 - TH1)，且 **T1 每溢出 32 次接收 1 bit**，所以波特率为 SysClk / 12 / (256 - TH1) / 32 = Bd。所以需要设置 Timer1 的初始值为 TH1 = 256 - 11059200 / 12 / 32 / 4800 = 256 - 6。
    - STC89C52 的 UART 的四种工作模式：
        - 模式0：同步移位寄存器
        - 模式1：8位UART，波特率可变（常用），无校验位，时序图如下 ![Alt text](./img/51_timing.png)
        - 模式2：9位UART，波特率固定，有校验位
        - 模式3：9位UART，波特率可变，有校验位
    - 串口内部结构简图
        - SBUF：串口数据缓存寄存器，**物理上是两个独立的寄存器，但占用相同的地址**。写操作时，写入的是发送寄存器，读操作时，读出的是接收寄存器。
            - 在 *发送过程* 中：写 SBUF 的指令会触发发送数据。在发送结束即 TI 被置 1 之前不能写 SBUF 否则会出错。（详见手册中的串行口工作模式）
            - 在 *接收过程* 中：接收器以给定波特率的 16 分频采样数据（即每次接收 1 bit，会采样 16 次）。如果没有数据则 RxD 端口将一直为 1；如果 RxD 从 1 变 0，则启动接收器并重置 16 分频计数器（即同步时间）开始接收一帧数据（8 bit + 起始位和结束位）。
            - 注意：通信双方需要约定好波特率，否则传输的数据将是错误的。
        - TL1, TH1：Timer1 相关寄存器。UART 想要工作，需要启用 Timer1，使用模式 2 **自动重装**定时器，并通过配置 Timer1 的溢出速度控制波特率。
        - TI, RI：触发同一个中断号的中断，**在中断处理函数中需要判断是读还是写触发了中断，在中断结束后需要用软件复位**。（详见上面的中断结构图）
        ![Alt text](./img/51_Serial.png)
8. 点阵屏
    - 大点阵屏一般是由 8 * 8 或者 16 * 16 的单位点阵屏拼接成的。
    - 显示原理：扫描（和数码管相同）
    - 74HC595
        1. 74HC595 是串行输入并行输出的移位寄存器
        2. OE(output enable) 低电平使能。且 OE 是由板子上的一个物理开关 J24 控制的，J24 把 OE 和 GND 接在一起的时候点阵屏才能点亮。
        3. SERCLK 出现上升沿时，移位寄存器往下移一位，并把 SER 中的数据填充在最低位。RCLK 出现上升沿时，把移位寄存器中的数据填充到输出寄存器中。 ![Alt text](./img/51_74H595.png)
        4. 74H595 的多片级联：QH' 连接下一个 74H595，可输出16位、24位、32位等，常用于IO口扩展。
        - 注意1：LED 的阳极连接 74H595，阴极直接连单片机的 IO 口。反过来不好，因为 IO 口输出高电平驱动能力差。
        - 注意2：74H595 恒压输出，驱动能力虽然比 IO 口直接驱动好一点，但是能力仍旧有限，所以亮一排灯和亮一个灯的亮度会有所区别。
    - 辅助软件：数字取模软件、图像取模软件。可制作滚屏字幕和逐帧动画。
9. DS1302
    - DS1302是由美国DALLAS公司推出的具有涓细电流充电能力的低功耗实时时钟芯片。
    - 所属大类 - RTC(Real Time Clock)：实时时钟，是一种集成电路，通常称为时钟芯片（例如：DS3231 精度高，DS12C887 内部自带电池）
    - 优点：相比单片机内部时钟，更精确，不占用 CPU 时间，断电继续运行（可连接备用电池，并具有涓细电流充电功能）
    - 引脚定义 ![Alt text](./img/51_DS1302_pin.png)
    - 时钟相关寄存器 ![Alt text](./img/51_DS1302_time_reg.png)
        - 前两列表示读或者写这行的寄存器的指令。指令是一个 8 位 2 进制数，详见下方指令格式。
        - $12/\overline{24}$ 表示如果这位为 1 就用 12 小时制，这位是 0 就用 24 小时制。 $\overline{AM}/PM$ 同理。
        - 10Seconds 和 Seconds 分别表示秒数的十位和各位，使用 BCD 编码。
        - WP: write protection，高电平则不能写入只能读出。**在初始化时需要把写保护关闭，否则可能导致读出的数据乱码。**
        - 最后一行是涓细电流充电相关寄存器，可以先不管。
        - 注意：一般情况下寄存器默认上电置 1，是一个不合法的时间。所以**需要给 DS1302 赋一个时间初值，否则不会开始计时**。
    - 指令的编写
        - 指令格式：![Alt text](./img/51_DS1302_com_reg.png)
        - 输入指令时序图：SCLK 上升沿写入数据，下降沿读出数据
            - 用 C 语言实现上升沿和下降沿：连续赋值 `SCLK = 0; SCLK = 1;`
            - 高电平和低电平需要至少保持一定的时间（参考手册并增加延时，或者用其他语句占用时间，**若不考虑保持时间可能会导致读出数据乱码**）
            - **读完之后必须要把 IO 口置 0**，否则下次读可能乱码，目前不知道为什么 ![Alt text](./img/51_DS1302_timing.png)
10. 蜂鸣器
    - 分类：
        - 有源蜂鸣器：内部自带振荡源，将正负极接上直流电压即可持续发声，**频率固定**
        - 无源蜂鸣器：内部不带振荡源，需要控制器提供振荡脉冲才可发声，**调整提供振荡脉冲的频率，可发出不同频率的声音**
    - 正负极：外壳上有正极的标志，或者长引脚为正。
    - 驱动芯片：ULN2003D 芯片
        - 达林顿晶体管阵列。可以看成一堆非门，但是只有输出 0 具有驱动能力，输出 1 不具备驱动能力![Alt text](./img/51_ULN2003D.png)
    - 音符与频率对照表 ![Alt text](./img/51_tune.png)
        - 小字组 a (440Hz) 是基准频率
        - 高八度频率翻倍
        - 八度中间的黑键和白键频率按等比数列划分（**十二平均律**）
    - 实现：
        - 用定时器中断实现音高。通过音符频率计算定时器中断的周期，每次中断翻转 IO 口电平
        - 在主函数中用循环实现时值。**一般将频率高、耗时短的周期性操作放在定时器中；频率低，耗时长的周期性操作放在主函数中。** 这样基本可以做到互不影响。
    - 后续改进：
        1. 因为芯片内部时钟非常不精准，所以音准差的有点离谱，可以试一个系数出来把每个频率都乘这个系数。
        2. 当蜂鸣器频率很快，即中断的频率很高时，CPU 效率降低导致原来一拍的时间边长了，需要修改一拍的时间，或者减少中断函数的耗时。
11. AT24C02
    - AT24C02是一种可以实现掉电不丢失的存储器
    - 存储介质 E2PROM，容量：256字节
        - 补充知识
            1. ROM 的发展史：Mask ROM（二极管焊死，不可编程。**用二极管而不是导线的原因是，防止逆向电流使其他地址线导通**）, PROM（二极管可以通大电流烧毁，把断路变成导通，所以只能进行一次编程）, EPROM（紫外线照射可以把烧毁的二极管重新导通，可以多次编程）, EEPROM(也叫 E2PROM，不用紫外线照了，通电就行) ![Alt text](./img/51_ROM.png)
            2. ROM 含义的拓展：原指只读存储器，后扩大为非易失性存储器的统称。硬盘（磁介质）、光盘（光介质）都算 ROM。
    - I2C 总线(Inter IC BUS, IIC)
        - 引脚：两根通信线 SCL（Serial Clock）、SDA（Serial Data）
        - 性质：同步（有时钟）、半双工（发送和接收分时复用一根数据线），带数据应答
        - 芯片举例：MPU6050 陀螺仪芯片，0.96 寸 OLED 屏幕
        - 电路规范：所有 I2C 设备的 SCL 连在一起，SDA 连在一起。设备的 SCL 和 SDA 均要配置成 **开漏输出模式（输出 0 直接接地，输出 1 相当于引脚断路）**。SCL 和 SDA 各添加一个上拉电阻，阻值一般为 4.7KΩ 左右。开漏输出和上拉电阻的共同作用解决了多机通信互相干扰的问题（除了输出信号的设备，其他接收设备输出 1，就只有一个设备在影响总线上的电位） ![Alt text](./img/51_I2C_circuit.png)
        - 时序结构模块（数据帧的组成部分）
            1. 起始条件 S(tart)：SCL高电平期间，SDA从高电平切换到低电平 ![Alt text](./img/51_I2C_S.png)
            2. 终止条件 （sto）P：SCL高电平期间，SDA从低电平切换到高电平 ![Alt text](./img/51_I2C_P.png)
            3. 发送一个字节 S(end) Byte：SCL低电平期间，主机将数据位依次放到SDA线上（高位在前），然后拉高SCL，从机将在SCL高电平期间读取数据位，所以SCL高电平期间SDA不允许有数据变化，依次循环上述过程8次，即可发送一个字节 ![Alt text](./img/51_I2C_SByte.png)
            4. 接收一个字节 R(eceive) Byte：SCL低电平期间，从机将数据位依次放到SDA线上（高位在前），然后拉高SCL，主机将在SCL高电平期间读取数据位，所以SCL高电平期间SDA不允许有数据变化，依次循环上述过程8次，即可接收一个字节（主机在接收之前，需要释放SDA） ![Alt text](./img/51_I2C_RByte.png)
            5. 发送应答 S(end) A(cknowledge)：在接收完一个字节之后，主机在下一个时钟发送一位数据，数据0表示应答，数据1表示非应答 ![Alt text](./img/51_I2C_SA.png)
            6. 接收应答 R(eceive) A(cknowledge)：在发送完一个字节之后，主机在下一个时钟接收一位数据，判断从机是否应答，数据0表示应答，数据1表示非应答（主机在接收之前，需要释放SDA） ![Alt text](./img/51_I2C_RA.png)
        - 数据帧
            1. 发送帧 ![Alt text](./img/51_I2C_send.png)
            2. 接收帧 ![Alt text](./img/51_I2C_receive.png)
            3. 符合格式帧（先发送再接收） ![Alt text](./img/51_I2C_mix.png)



## 项目记录

1. DS1302 可调时钟
    1. 如何使程序逻辑更清晰：
        - 整个程序只有一个循环！在循环中通过判断选择相应行动。不要把逻辑写成先判断再各自进入不同的循环，容易边麻烦。
        - 模式选择的程序思维！把时钟模式和调节模式视作两种并列的模式
        - 在每个 while 循环中都先检查是否有按键按下，如果切换模式的按键按下就做出相应操作，然后根据模式选择进行行动。
    2. 在功能较多时如何选择合适的实现顺序：
        - 先实现显示功能
        - 再增加调节模式（只显示进入调节模式无实际功能）
        - 编写调节模式功能
        - 再增加判断时间合法性
        - 最后写中断增加闪烁
    3. 遇到的奇怪错误：
        - choose 作为参数传入函数，在调用 `LCD_ShowNum()` 后会被修改，但是作为全局变量就不会。
        - 读完之后必须要把 IO 口置 0，否则下次读可能乱码
    4. 后续改进：利用定时器中断实现按键上升沿和下降沿的捕获





